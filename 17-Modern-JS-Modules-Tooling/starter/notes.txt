// MODULES
Modules are resuable pieces of code that encapsulates implementation details

Is usually a standalone file.
Not always the case, but when we think of modules, it's usually a file
can have imports and exports


Whatever we export from modules is called the public API
This is just like classes, where we can expose a public API for other code to consume


In the case of modules, this public API is actually 
consumed by importing values into a module

These other modules we import are then called "Dependancies" 
of the importing module, because the module "depends" on them to function.
The module cannot work without the importing code.


Modules make it easy to compose software, they are a bit like building blocks
to build more complex applications, or loops and samples in audio work.

Modules allow codes to split up and worked on by individual engineers.
Isolating components is a huge advantage of using modules.

Make it very easy to abstract or code - we can use modules to implement low level code
Modules allow for a more organised code base.

Modules allow us to reuse the same code in a project, or multiple projects.

As of ES6 js has a native built-in module system
Did have them before, but had to be implemented by engineer or use external libraries

Modules are stored as one module per file.


Diff between script and ES6 modules

ES6 
All top level variables are scoped to module 
The only way an outside module can access a value that's inside of a module
Is if the inside module exports that value.
If we don't export, we cannot see the variable from outside.
Always in strict mode
Top-level this is always undefined
We can import/export values between modules

link in HTML with <script type ="module"></script>

In scripts
All top level variables are global
Private variables are the solution to this problem (with modules)
Non-strict mode by default
Top-Level this points at the window object
Importing/Exporting values is impossible
link with <script></script>



[
import { rand } from '.math.js';
import { showDice } from '.dom.js';
]
The above is importing a value called rand from teh math.js module
And importing showDice from .dom.js module


The whole process of importing modules happens before code in 
the main module is actually executed

Only after all imported modules have been downloaded and executed, 
the main index.js module will be finally be executed

Modules are imported synchronously
This is possible thanks to top-level(static) imports, 
which make imports known before execution

Once parsing has completed, downloading of modules begins (downloading is asynchronous)
It is only the importing operation itself that is synchronous.

When a module is downloaded, it is parse and linked to index.js module.
And this connection is a life connect, epxorted values are not copied to imports. 
The import is basically a reference to the export at value.

So when the value changes in the exporting module, this is reflected in the importing module.
This is unique to ES6 modules.

Other module systems do not work like this, but js modules do!

Code in imported modules is then executed, and the process completes.

In ES2022, we can now use await keyword outside of async functions, atleast in modules
While very useful, this blocks the execution of the entire module now

One more important implication of top level await, if one module imports a module that has top level await
then the importing module will wait for the imported module to finish the blocking code.

Await outside of any async function can block function in it's own module, and any script that imports it as a module.


you can rebuild node_module folder with npm -i
(this is yarn at work.. what are the similarities between the two?)


Parcel is a bundler.
It's another build tool on npm
install as a dev Dependancies 
This separates them from regular dependancies like mapty
--save-dev

In the current situation, Parcel's job is to bundle together script.js,shoppingCart.js and cloneDeep.js
two options to use Parcel
NPX
app built into NPM
"npx parcel starter/index.html"


Parcel then starts a development server to preview code like using live server. 

creates a dist folder, there is a js script (our blundled code) and a map file


Parcel will rebuild with every saved change of code by default, so no need to manually push each time

/*
//Hot Module - This will allow stop reloading of the whole change when saving code changes
if (module.hot){
    module.hot.accept()
}
*/

NPM Scripts
another way of runniung local packages in command line
allow us to automate repetitive tasks

We can add this to package.json

"scripts": {
    "start": "parcel .\\starter\\index.html"
  },

  then run "npm run start" in terminal.

  This will bundle via parcel


  we can also install packages globally with the G argument
  npm i parcel -g

  difference between globally and locally is that we can use global tools directly in command line without intermediate npm script


  // Babel 
  Babel is a js compiler we can use to ensure internet users on older tech
  Old browsers can access our site, without the code being "too modern"

Converts modern code into classic alternatives

Babel can only transpile ES6 syntax, like arrow functions, classes, const or spread operator
Things that have an equivalent way of writing in ES5

i.e const > var

This is not true for newer methods like find and Promise. 
New additions to the language are simply not transpiled
Syntax is easy to compile

For the new methods, we can polyfill these 

// Polyfilling

Babel used to polyfill, but now they recommend 3rd parties. 

import 'core-js/stable'

Promise and find are not changed in script.
What polyfilling does is to recreate defined functions and make them avilable in the bundle so the code can use it.

We can cherry pick what is polyfilled and omit what we don't want to to reduce bundle size
import 'core-js/stable/find' --Just the find method
import 'core-js/stable/promise' etc..

One feature that isn't covered by polyfill - async functions
npm install regenerator-runtime
import 'regenerator-runtime/runtime';


// READABLE CODE
// Always write readable code
// Avoid trying to write too clever or over complicated solutions, as this may contradict previous issue
// Use descriptive variable names "what they contain"
// Use desciprtion function names "what they do?"
// DRY - don't repeat yourself. Refactor code 
// Don't use var
// use strong type checks (=== and !==)

// FUNCTTONS
// Generally, functions should only do one Things
// Don't use more than 3 function parameters, try to return same data type as paramater data types
// Use default parameters whenever possible
// Generally return same data type as received
// Use arrow functions when they make code more readable

// OOP 
// Use ES6 classes
// Encapsulate data and don't mutate it from outside of the class
// Implement method chaining
// Do not use arrow functions as methods (in regular objects) as they have no access to the "this" keyword


// AVOID NESTED CODE
// Use early return
// use ternary (conditional) or logical operators instead of if
// Use multiple if instead of if/else-if
// Avoid for loops, use array methods instead
// Avoid callback-based asynchronous API

// ASYNCHRONOUS CODE 
// Consume promises with async/await for best readability
// Whenever possible, run promises in parallel (Promise.all)
// Handle errors and promise rejections


There are two fundamentally different ways of writing code (also know as paradigms)
Imperative , and Declarative

Whenever we write imperative we need to explain how to do certain things, every step the compute rneeds to follow

Example would be a step-by-step recipe of a cake
or the following 
  const arr= [2,4,6,8];
  const doubled = []
  for (let i=0; i < arr.length; i++)
  doubled[i] = arr[i] * 2;


Declarative programming tells what to do
We simply describe tyhe way the computer should achieve the result
the "how" gets abstracted away
Example : description of a cake

  const arr = [2,4,6,8]
  const doubled = arr.map(n => n*2);


// Functional programming
- Declarative programming paradigms
- Based on the idea of writing osftware by combining many 
  pure functions, avoiding side effects and mutating data
- Side effct is a modification (mutatioon) of any data outside of the function 
  (mutating external variables, logging to console, writing to DOM etc.)
- A pure function is a function without side effects. Doesn't depend
  on external variables. Given the same inputs, it will always return the same output

we use immutability to avoid mutating external data.
- Immutability: State (data) is never modified. Instead, 
  state is copied and the copy is mutated and returned.

Difficult to implement in practise

React and Redux are built primarily around Functional programming


We can mix imperative and declarative in our own code, 
it doesn't have to be all of one.


Functional Programming Techniques
- Try to avoid data mutations
- Use built-in methods that don't produce side effects
- Do data transformations with methods such as .map() .filter() and .reduce
- Try to avoid side effects in functioons: this may not always be possible.

Declarative Syntax
- Use array and object destructuring
- Use the spread operator (...)
- Use the ternary operator (true === true ? "true" : "false")
- Use template literals `üêà`

